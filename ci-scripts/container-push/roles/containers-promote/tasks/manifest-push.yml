---
# These tasks create a container manifest in {{registry.host}} with references
# to both _x86_64 and ppc64le tagged container images. If ppc build is missing
# the manifest will contain only the x86 image.
# First pull the _arch tagged images from rdo, tag and push {{ hash }}_{{ arch }}
# to {{registry.host}}. Then create and push the manifests pointing to {{ hash }}_{{ arch }}
# containers. The manifest is named {{container-name}}:{{full_hash}}_manifest
#

- name: 'Check if {{ ppc_tag }} container exists in {{ source_registry.host }}'
  shell: |
    export DOCKER_CLI_EXPERIMENTAL=enabled
    if docker manifest inspect --insecure "{{ source_registry.host }}/{{ source_registry.namespace }}/{{ item }}"  1>/dev/null;
        then
            echo "$image OK";
        else
            echo "$image ERROR";
        fi
    done
  register: check_ppc_containers
  failed_when: false
  loop: "{{ built_images.stdout_lines }}"
  retries: 1

- debug:
    msg: "manifest-push.yml debug:{{ ppc_tag }} container not found for {{ item }}"
  loop_control:
    index_var: index
  when: '"ERROR" in check_ppc_containers.results[index].stdout'
  loop: "{{  built_images.stdout_lines }}"

- name: 'Pull {{ x86_tag }} tagged container images from {{ source_registry.host }}'
  docker_image:
    name: "{{ source_registry.host }}/{{ source_registry.namespace }}/{{ distro_name }}-binary-{{ item }}"
    tag: "{{ full_hash }}_{{ x86_tag }}"
    source: pull
  loop: "{{ built_images.stdout_lines }}"
  retries: 3

- name: 'Pull {{ ppc_tag }} tagged container images from {{ source_registry.host }} registry'
  docker_image:
    name: "{{ source_registry.host }}/{{ source_registry.namespace }}/{{ distro_name }}-binary-{{ item }}"
    tag: "{{ full_hash }}_{{ ppc_tag }} "
    source: pull
  loop: "{{ built_images.stdout_lines }}"
  loop_control:
    index_var: index
  when: '"OK" in check_ppc_containers.results[index].stdout'
  retries: 3

- name: tag and push {{ x86_tag }} container images to {{ registry.host }}
  docker_image:
    name: "{{ source_registry.host }}/{{ source_registry.namespace }}/{{ distro_name }}-binary-{{ item }}"
    tag: "{{ full_hash }}_{{ x86_tag }}"
    source: local
    repository: "{{ registry.host }}/{{ registry.namespace }}/{{ distro_name }}-binary-{{ item }}"
    push: yes
  retries: 3
  loop: "{{ built_images.stdout_lines }}"

- name: tag and push {{ ppc_tag }} container images to {{ registry.host }}
  docker_image:
    name: "{{ source_registry.host }}/{{ source_registry.namespace }}/{{ distro_name }}-binary-{{ item }}"
    tag: "{{ full_hash }}_{{ ppc_tag }}"
    source: local
    repository: "{{ registry.host }}/{{ registry.namespace }}/{{ distro_name }}-binary-{{ item }}"
    push: yes
  retries: 3
  loop: "{{ built_images.stdout_lines }}"
  loop_control:
    index_var: index
  when: '"OK" in check_ppc_containers.results[index].stdout'
  retries: 3

- name: Registry manifest_create_command with --insecure for local registry
  set_fact:
    manifest_extra_opts: "{% if registry.host is match('localhost') %}--insecure{% else %}{% endif %}"
# First create manifest for those containers built both in x86 and ppc
- name: create manifests for containers with both {{ x86_tag }} {{ ppc_tag }}
  shell: |
    docker manifest create {{ manifest_extra_opts }} {{ registry.host }}/{{ registry.namespace }}/{{ distro_name }}-binary-{{ item }}:{{ full_hash }}{{ manifest_tag }} {{ registry.host }}/{{ registry.namespace }}/{{ distro_name }}-binary-{{ item }}:{{ full_hash }}_{{ x86_tag }} {{ registry.host }}/{{ registry.namespace }}/{{ distro_name }}-binary-{{ item }}:{{ full_hash }}_{{ ppc_tag }}
    docker manifest annotate --arch amd64 {{ registry.host }}/{{ registry.namespace }}/{{ distro_name }}-binary-{{ item }}:{{ full_hash }}{{ manifest_tag }} {{ registry.host }}/{{ registry.namespace }}/{{ distro_name }}-binary-{{ item }}:{{ full_hash }}_{{ x86_tag }}
    docker manifest annotate --arch {{ ppc_tag }}  {{ registry.host }}/{{ registry.namespace }}/{{ distro_name }}-binary-{{ item }}:{{ full_hash }}{{ manifest_tag }} {{ registry.host }}/{{ registry.namespace }}/{{ distro_name }}-binary-{{ item }}:{{ full_hash }}_{{ ppc_tag }}
  loop_control:
    index_var: index
  loop: "{{ built_images.stdout_lines }}"
  when: '"OK" in check_ppc_containers.results[index].stdout'

# Now create manifest for the rest of the x86 only containers
- name: create manifests for {{ x86_tag }} only containers
  shell: |
    docker manifest create {{ manifest_extra_opts }} {{ registry.host }}/{{ registry.namespace }}/{{ distro_name }}-binary-{{ item }}:{{ full_hash }}{{ manifest_tag }} {{ registry.host }}/{{ registry.namespace }}/{{ distro_name }}-binary-{{ item }}:{{ full_hash }}_{{ x86_tag }}
    docker manifest annotate --arch amd64 {{ registry.host }}/{{ registry.namespace }}/{{ distro_name }}-binary-{{ item }}:{{ full_hash }}{{ manifest_tag }} {{ registry.host }}/{{ registry.namespace }}/{{ distro_name }}-binary-{{ item }}:{{ full_hash }}_{{ x86_tag }}
  loop_control:
    index_var: index
  loop: "{{ built_images.stdout_lines }}"
  when: '"ERROR" in check_ppc_containers.results[index].stdout'

- name: push container manifests to {{ registry.host }}
  shell: |
    docker manifest push {{ registry.host }}/{{ registry.namespace }}/{{ distro_name }}-binary-{{ item }}:{{ full_hash }}{{ manifest_tag }}
  retries: 3
  with_items: "{{ built_images.stdout_lines }}"
