---
- name: Login to registry
  docker_login:
    registry_url: "{{ registry.auth_url }}"
    username: "{{ registry.username }}"
    password: "{{ registry.password }}"
    reauthorize: "yes"
  no_log: true
  when: "registry.auth_url is defined and registry.auth_url != 'unused'"

# Workaround for https://github.com/ansible/ansible/issues/32868
- name: Validate target registry login
  block:
    - name: attempt a push to the logged in registry
      shell: >
        docker build -t {{ registry.host }}/{{ registry.namespace }}/nop - &&
        docker push {{ registry.host }}/{{ registry.namespace }}/nop
      args:
        stdin: |
          FROM scratch
          CMD touch foo
          ENTRYPOINT ""
  rescue:
    - debug:
        msg: |
          The workaround to test login failed, but we've seen it failing before and other push operation passing.
          We'll leave this rescue branch until the workaround is fixed, so we don't fail but we don't forget
  always:
    - name: locally remove validation container
      shell: |
        docker rmi {{ registry.host  }}/{{ registry.namespace  }}/nop || true

- name: Create public empty repositories on registry
  uri:
    url: "https://{{ registry.host }}/api/v1/repository"
    method: POST
    body_format: json
    body:
      namespace: "{{ registry.namespace }}"
      repository: "{{ distro_name }}-binary-{{ item }}"
      description: "TripleO container for {{ distro_name }}-binary-{{ item }}"
      visibility: public
    headers:
      Authorization: "Bearer {{ registry.token }}"
      Content-Type: "application/json"
    status_code:
      - 400
      - 201
  loop: "{{ built_images.stdout_lines }}"
  register: image_result
  until: image_result is success
  retries: 2
  when: registry.create_repo|default(false)|bool

# Nested loop order here is on purpose, so we push first all the images with the full hash, then we tag with the named label.
- name: Tag and push images to registry
  when: not manifest_push|bool
  docker_image:
    name: "{{ source_registry.host }}/{{ source_registry.namespace }}/{{ distro_name }}-binary-{{ item[1] }}"
    tag: "{{ item[0] }}"
    repository: "{{ registry.host }}/{{ registry.namespace }}/{{ distro_name }}-binary-{{ item[1] }}"
    push: yes
    source: local
    # This force-tag is absolutely needed, if image exists with this tag,
    # docker_image will not try a push without this flag
    force_tag: yes
  with_nested:
    - ["{{ full_hash }}", "{{ named_label }}"]
    - "{{ built_images.stdout_lines }}"
  register: pushed
  retries: 3
  tags:
    - dockerhub_push

# Push containers tagged with only label if we are also pushing manifests
# Create and push container manifests to registry.host with _x86_64 and ppc64le
# tagged containers. Multi arch manifest is only compatible with v2_s2 API schema
- name: 'Tag and push container with {{ named_label }} then push manifests'
  when:
    - "manifest_push|bool"
    - "registry.schema|default('v2_s1') == 'v2_s2'"
  block:
    - name: 'Tag with {{ named_label }} and push to {{ registry.host }}'
      docker_image:
        name: "{{ source_registry.host }}/{{ source_registry.namespace }}/{{ distro_name }}-binary-{{ item.1 }}"
        tag: "{{ item.0 }}"
        repository: "{{ registry.host }}/{{ registry.namespace }}/{{ distro_name }}-binary-{{ item.1 }}"
        push: yes
        source: local
        # This force-tag is absolutely needed, if image exists with this tag,
        # docker_image will not try a push without this flag
        force_tag: yes
      loop: "{{ [named_label]|product(built_images.stdout_lines) |list }}"
      register: pushed
      retries: 3
      tags:
        - dockerhub_push
    - name: 'Push {{ x86_tag }} {{ ppc_tag }} containers and manifests to {{ registry.host }}'
      include_tasks: manifest-push.yml


- name: Check if images were pushed
  shell: |
    tag={{ full_hash }}
    for image in $(cat {{ containers_file }})
    do
        if docker manifest inspect --insecure "{{ registry.host }}/{{ registry.namespace }}/{{ distro_name }}-binary-${image}:${tag}" 1>/dev/null;
        then
            echo "$image OK";
        else
            echo "$image ERROR";
        fi
    done
  register: command_result
  failed_when: "'ERROR' in command_result.stdout or command_result.rc != 0"
  retries: 1
  changed_when: false
  # manifest commands are only compatible with v2_s2 API schema
  when: "registry.schema|default('v2_s1') == 'v2_s2'"

- name: Add pushed containers to the cleanup list
  set_fact:
    pushed_containers: "{{ pushed_containers + [item.invocation.module_args.repository + ':' + item.invocation.module_args.tag] }}"
  loop: "{{ pushed.results }}"
  loop_control:
      label: "{{ item.invocation.module_args.repository + ':' + item.invocation.module_args.tag }}"
